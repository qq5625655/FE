# FE
这是一个xmind的集合





HTML:
    -.HTML的输入url，到解析流程。
    1.浏览器接收url，开启网络线程
    2.开启网络线程后，发起http请求
        2.1 dns查询，tcp/ip五层网络协议，应用(http, http2, quic)、传输(tcp/ip三次握手)、网络、数据链路、物理
    3.从服务器接受请求后，对应后台请求。(ngnix, tomcat等)
        3.1 前台与后台的http交互
    4.http1.0，2.0，3.0 https， 
    HTML预防攻击(xss、sql注入)
JS:
    1.数据类型，深浅拷贝， 传递参数，值和对象。
    2.防抖，节流.
    3.异步(宏任务，微任务)
    4.promise 手写
    5.原型与原型链， 正常继承，非对象继承， new的实现，call，apply，bind的实现。
    6.js的大文件上传(学会)
    7.js的bridge
    8.大量数据瞬间插入到dom里面

React:
    1.对于内部的使用，优化更新的(memo, userMemo)
    2.React fiber的思想.
    3.react的diff
Vue:
    1.Vue的diff,  v2和v3
    2.Vue的加载过程。
    3.Vue的vue-router.
    4.Vue的keep-alive.
node:
    1.node的方法
    2.process.cwd, process.env
    3.fs
    4.stream
leetcode:
    1.翻转链表
    2.删除链表的倒数第N个节点(slow, fast)，fast先走N步，然后同时开始走，这样就能删除slow的节点.
    3.环链表，slow，fast，当相遇就有环，然后index1=head，index2=fast,同时走一步，相交就是环入口。
    map，hash等。
    1.添加类型++, 然后在--，大于0就false，否则返回true
    2.targrt-num， 然后判断
    二叉树：
    1.二叉树的前、中、后遍历，迭代与递归的写法
    2.二叉的广度遍历、层序遍历
    3.二叉树的翻转，递归，迭代,
    4.二叉树的高度，深度遍历,后续遍历
    5.二叉树的最小高度，要判断边界，只有左右子树都不为空才可以
    6.二叉树构造，中序和后续，前序和中序
    7.公共祖先问题, 后续遍历，然后判断p、q或者null，返回当前节点, 然后left，right判断是否为空
    8.二叉搜索树的公共祖先，通过二叉搜索的特定去判断
    9.二叉搜索树的删除，有点难度，分情况考虑，
        @.没有孩子节点，直接删除。
        @.没有左孩子或者右孩子，返回相对应的孩子节点
        @.左右孩子都有，那么将删除节点的左孩子的头结点，赋值到右孩子的最左边的孩子节点上。
    动态规划：
    1.爬楼梯，dp(n-1), dp(n-2)
    2.整数拆分, dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)); dp[2] = 1 ,初始化为dp[2]
    3.不同的二叉搜索树, dp[3]= 下标为1头结点+下标为2头结点+下标为3头结点。
        下标为1头结点，右子树有2个节点，左子树为0 = dp[2]*dp[0];
        下标为2头结点，右子树有1个节点，左子树为1 = dp[1]*dp[1];
        下标为3头结点，右子树有0个节点，左子树为2 = dp[0]*dp[2];
    4.背包问题,0/1背包
    4.1原始背包，物品重量为[1,3,4], 价值为[15, 20, 35]; i为物品，j为容量
    if(wight[i - 1] <= j) {
        dp[i][j] = Math.max(
          dp[i - 1][j], 
          value[i - 1] + dp[i - 1][j - wight[i - 1]]
        )
    // 一维滚动数组
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
        4.2子集相等,target = sum/2,然后套公式
        4.3石头相等,sum/2
        4.4目标和，有点麻烦，加号部分+减号部分的绝对值 = sum
            假设加号部分为X，减法对应就是sum-x
            根据公式推断出，我们所求的就是X-(sum-x)=S
            X=(S+sum)/2
            之所以用加号，是因为加号部分被背包容量
    完全背包：
        4.5零钱兑换2: 有零钱，能够无线兑换，问你有几种凑成的方式，完全背包和0/1背包一样，只不过这个从前往后遍历
            dp[j] += dp[j - coins[i]];
        4.6组合总和, 原来是先遍历物品，然后再遍历背包，现在需要先遍历背包，在遍历物品.
            dp[i] += dp[i - num[j]];
        4.7零钱兑换： 兑换最小硬币，这个也是组合，不是排列
            dp[j] += math.min(dp[j - coins[i]] + 1, dp[j]);
        4.8完全平方: n为背包，i为物品， j*j <=i, 走排列的形式
            dp[i] = min(dp[i - j * j] + 1, dp[i]);
        4.9单词拆分: 进行相应的判断,只要前面的值是单词，然后在判断后面的是不是

    打家劫舍：
        4.10, dp[i]:能够偷的是最大值，隔一间偷一次，dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        4.11， 环形, dp[i]方法，方法[0, len-2], 方法[1, len-1]
        4.12  树形，0，代表不偷，1代表偷， 
            / 不偷当前节点，左右子节点都可以偷或不偷，取最大值
            const DoNot = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
            // 偷当前节点，左右子节点只能不偷
            const Do = node.val + left[0] + right[0];
        
    股票：
        4.13, 只买卖一次，dp[i][0]: 持有股票所获得的最多现金, dp[i][1] 不持有股票获得最多现金
            因为只能买卖一次，所以方法就是 dp[i][0] = max(dp[i][0], -price[i])
        4.14
            能买卖多次，所以就说dp[i][0] = max [dp[i][0],dp[i][1]-price[i]]
        4.15 买卖2次，所以可以买卖2次，也可以买卖1次，
            0：无操作
            1: 第一次买入股票
            2: 第一次卖出股票
            3: 第二次买入股票
            4: 第二次卖出股票
        所以操作就是这种操作.
        4.16 买卖K次，所以就是使用      前面一个for循环，套一个for循环.
                                         for (int j = 0; j < 2 * k - 1; j += 2)
        4.17冷冻期，初始化要两天，然后卖的时候要i-2
    最长系列：
        4.18最长递增子序列, dp[i]包括之前的就是 num[i] > num[j] dp[i] = max(dp[i], dp[j] + 1); vue3diff算法
        4.19最长连续递增子序列，nums[i] > nums[i+1] 
        4.20最大和的连续自数组，dp[i - 1]+nums[i] , nums[i]
        4.21最长重复自数组, 编辑距离,dp，i-1为结尾的的A，和j-1为结尾的B，dp[i][j]  = dp[i-1][j-1] + 1;
        4.22最长公共子序列, 判断是否相等，相等不说，+1，不想动，判断s字符串最大还是t字符串最大
        4.23判断子序列, dp[i] = dp[i-1][j-1], 否则dp[i][j-1]
        4.24两个字符删除，相等就评议，不相等，就根据情况
        4.25回文
        4.26回文长度
        4.27求雨水发






react: 
    1.
            
        
    




    