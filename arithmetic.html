<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 1.背包基础
        function bag(weight, bagWeight){
            let dp = new Array(bagWeight+1);
            for (let i = 0; i < weight; i++) {
                for (let j = bagWeight.len - 1; j < bagWeight; j++) {
                    dp[j] = Math.max(dp[j], dp[j-weight[j]]+value[i]);
                    
                }
            
            }
        }
        // 组合总和 Ⅳ
        // 示例 1： 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4
        function coin(n){
            let dp = new Array(amount+1).fill(0);
            // 凑成N需要最少需要多少个,完全平方是物品.
            // 凑成dp[n]最少有n种
            // 背包
            for (let i = 1; i <= n; i++) {
                // const element = array[i];
                for (let j = 1; j*j <= n; j++) {
                    // const element = array[j];
                    // dp[j] += 
                    if(n <= j*j){
                        // dp[j] = Math.min(dp[j], dp[j-coins[i]]+1);
                        dp[i] = Math.min(dp[i], dp[i - j*j]+1)
                    }
                }
            }
            console.log('dp', dp[amount]);
        }
        // coin([1, 2, 5], 5);
        // 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
        // 示例 1： 输入: s = "leetcode", wordDict = ["leet", "code"] 输出: true 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
        function wordBreak(s, wordDict){
            // dp[i] 代表字符s[i]是否能够拆分
            // 背包为S
            for (let i = 0; i < s.length; i++) {
                // const element = array[i];
                for (let j = 0; j < i; j++) {
                    let word = s.subString(j, i-j);
                    if(wordDict.indexOf(word) !== -1 && dp[j]){
                        dp[i] = true;
                    }
                    
                }
            }
        };
        // 打家劫舍
        function main(arr){
            let max1 = rob(arr.slice(0, arr.length - 2));
            let max2 = rob(arr.slice(1, arr.length - 1));
            console.log(Math.max(max1, max2)); 
        }
        function rob(arr){
            let dp = new Array(arr + 1);
            dp[0] =  arr[0];
            dp[1] = Math.max(arr[0], arr[1]);
            for (let i = 2; i < arr.length; i++) {
                // const element = array[i];
                dp[i] = Math.max(dp[i - 1], dp[i - 2]+arr[i]);
                
            }
            return dp[arr.length - 1]
        }
        main([1,6,1,9,1]);
        // 大家劫舍

        function robTree(root){
            // dp数组，0代表不抢当前节点，1代表抢劫当前节点
            let left  = robTree(root.left);
            let right = robTree(root.rigth);
            if(!root.left && !root.rigth){
                return [0, root.value]
            }
            // if(){}
            let rob = root.value + left[0] + rigth[0];
            let noRob = left[1] + rigth[1];
            // let value = Math.max(rob, noRob);
            return [noRob, rob];

        }
        // 股票
        //输入：[7,1,5,3,6,4]
        //输出：5
        //解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
        //注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
        function maxProfit(arr){
            // dp[i][0] 持有股票的最大值
            // dp[i][1] 不持有股票的最大值
            // dp[i][0] 由两个方向，dp[i][0]， 前一天买股票，dp[i-1][0], 今天买股票-price[i]
            // dp[i][1] 两个放心，前一天的现金，和今天股票卖出去的现金
            dp[0][0] = -arr[0];
            dp[0][1] = 0;
            for (let i = 1; i < arr.length; i++) {
                // const element = array[i];
                // k次交易
                // dp[i][0] = -prices[i];
                for (let k = 0; k < 2 * k - 1; k+2) {
                    // const element = array[k];
                    dp[i][k+1] = max(dp[i - 1][k + 1], dp[i][k] - prices[i]);
                    dp[i][k+2] = max(dp[i - 1][k + 2], prices[i] + dp[i - 1][k+1]);
                    
                }
                
                
            }
            return dp[len - 1][1];
        }
        // 最连续长递增序列
        // 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
        // 输入："aaa" 输出：6 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"

        function increase(str){
            // 前序迭代
            let stack = [];
            stack.push(node);
            while (stack.length !== 0) {
                let node = stack.shift();
                
                if(node){
                    stack.push(node);
                    node = node.left;
                }else{
                    let left  = stack.pop();

                }

                // if(node.rigth){
                //     stack.push(node.right);
                // }
            }
            
        };
        // 链表和树，也得看看
    </script>
</body>
</html>